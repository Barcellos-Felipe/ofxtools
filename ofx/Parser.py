# vim: set fileencoding=utf-8

# stdlib imports
import xml.etree.ElementTree as ET
import re


# local imports
from header import OFXHeader
import aggregates
import elements


class ParseError(SyntaxError):
    """ Exception raised by parsing errors in this module """
    pass


class ElementTree(ET.ElementTree):
    """ 
    Subclass of ElementTree.Element Tree with overriden parse() method that 
    validates/strips the OFX header, then feeds the body tags to custom
    TreeBuilder subclass.
    """
    def parse(self, source):
        if not hasattr(source, 'read'):
            source = open(source)
        source = source.read()

        # Validate and strip the OFX header
        source = OFXHeader.strip(source)

        # Then parse tag soup into tree of Elements
        parser = TreeBuilder(element_factory=Element)
        parser.feed(source)
        self._root = parser.close()

    def convert(self, strict=True):
        if not hasattr(self, '_root'):
            raise ValueError('Must first call parse() to have data to convert')
        # OFXResponse performs validation & type conversion
        return OFXResponse(self, strict=strict)


OFXParser = ElementTree


class TreeBuilder(ET.TreeBuilder):
    """ 
    Subclass of ElementTree.TreeBuilder with a custom feed() method implementing
    a regex-based parser for SGML
    """
    # The body of an OFX document consists of a series of tags.
    # Each start tag may be followed by text (if a data-bearing element)
    # and optionally an end tag (not mandatory for OFXv1 syntax).
    regex = re.compile(r"""<(?P<TAG>[A-Z1-9./]+?)>
                            (?P<TEXT>[^<]+)?
                            (</(?P=TAG)>)?
                            """, re.VERBOSE)

    def feed(self, data):
        """
        Iterate through all tags matched by regex.
        For data-bearing leaf "elements", use TreeBuilder's methods to
            push a new Element, process the text data, and end the element.
        For non-data-bearing "aggregate" branches, parse the tag to distinguish
            start/end tag, and push or pop the Element accordingly.
        """
        for match in self.regex.finditer(data):
            tag, text, closeTag = match.groups()
            text = (text or '').strip() # None has no strip() method
            if len(text):
                # OFX "element" (i.e. data-bearing leaf)
                if tag.startswith('/'):
                    msg = "<%s> is a closing tag, but has trailing text: '%s'"\
                            % (tag, text)
                    raise ParseError(msg)
                self.start(tag, {})
                self.data(text)
                # End tags are optional for OFXv1 data elements
                # End them all, whether or not they're explicitly ended
                try:
                    self.end(tag)
                except ParseError as err:
                    err.message += ' </%s>' % tag # FIXME
                    raise ParseError(err.message)
            else:
                # OFX "aggregate" (tagged branch w/ no data)
                if tag.startswith('/'):
                    # aggregate end tag
                    try:
                        self.end(tag[1:])
                    except ParseError as err:
                        err.message += ' </%s>' % tag # FIXME
                        raise ParseError(err.message)
                else:
                    # aggregate start tag
                    self.start(tag, {})
                    # empty aggregates are legal, so handle them
                    if closeTag:
                        # regex captures the entire closing tag
                       assert closeTag.replace(tag, '') == '</>'
                       try:
                           self.end(tag)
                       except ParseError as err:
                           err.message += ' </%s>' % tag # FIXME
                           raise ParseError(err.message)

    def end(self, tag):
        try:
            super(TreeBuilder, self).end(tag)
        except AssertionError as err:
            # HACK: ET.TreeBuilder.end() raises an AssertionError for internal
            # errors generated by ET.TreeBuilder._flush(), but also for ending
            # tag mismatches, which are problems with the data rather than the
            # parser.  We want to pass on the former but handle the latter;
            # however, the only difference is the error message.
            if 'end tag mismatch' in err.message:
                raise ParseError(err.message)
            else:
                raise


class Element(ET.Element):
    """
    Subclass of ElementTree.Element extended to handle validation and type
    conversion of OFX Aggregates.
    """
    def convert(self, strict=True):
        """ 
        Convert a parsed OFX aggregate into a flat dictionary of its elements
        """
        if self.tag == 'MFINFO':
            # Strip MFASSETCLASS/FIMFASSETCLASS 
            # - lists that will blow up _flatten()

            # Do all XPath searches before removing nodes from the tree
            #   which seems to mess up the DOM in Python3 and throw an
            #   AttributeError on subsequent searches.
            mfassetclass = self.find('./MFASSETCLASS')
            fimfassetclass = self.find('./FIMFASSETCLASS')

            if mfassetclass is not None:
                # Convert PORTIONs; add to list on MFINFO
                self.mfassetclass = [p.convert() for p in mfassetclass]
                self.remove(mfassetclass)
            if fimfassetclass is not None:
                # Convert FIPORTIONs; add to list on MFINFO
                self.fimfassetclass = [p.convert() for p in fimfassetclass]
                self.remove(fimfassetclass)
                    
        attributes = self._flatten()

        # Aggregate classes are named after the OFX tags they represent.
        # Use the tag to look up the right aggregate
        AggregateClass = getattr(aggregates, self.tag)

        # See OFX spec section 5.2 for currency handling conventions.
        # Flattening the currency definition leaves only the CURRATE/CURSYM
        # elements, leaving no indication of whether these were sourced from
        # a CURRENCY aggregate or ORIGCURRENCY.  Since this distinction is
        # important to interpreting transactions in foreign correncies, we
        # preserve this information by adding a nonstandard curtype element.
        if issubclass(AggregateClass, aggregates.ORIGCURRENCY):
            currency = self.find('*/CURRENCY')
            origcurrency = self.find('*/ORIGCURRENCY')
            if (currency is not None) and (origcurrency is not None):
                raise ParseError("<%s> may not contain both <CURRENCY> and \
                                 <ORIGCURRENCY>" % self.tag)
            curtype = currency
            if curtype is None:
                 curtype = origcurrency
            if curtype is not None:
                curtype = curtype.tag
            attributes['curtype'] = curtype

        # Feed the flattened dictionary of attributes to the converter
        aggregate = AggregateClass(strict=strict, **attributes)
        return aggregate


    def _flatten(self):
        """
        Recurse through aggregate and flatten; return an un-nested dict.

        This method will blow up if the aggregate contains LISTs, or if it
        contains multiple subaggregates whose namespaces will collide when
        flattened (e.g. BALAMT/DTASOF elements in LEDGERBAL and AVAILBAL).
        Remove all such hair from any element before passing it in here.
        """
        aggregates = {}
        leaves = {}
        for child in self:
            tag = child.tag
            data = child.text or ''
            data = data.strip()
            if data:
                # it's a data-bearing leaf element.
                assert tag not in leaves
                # Silently drop all private tags (e.g. <INTU.XXXX>
                if '.' not in tag:
                    leaves[tag.lower()] = data
            else:
                # it's an aggregate.
                assert tag not in aggregates
                aggregates.update(child._flatten())
        # Double-check no key collisions as we flatten aggregates & leaves
        for key in aggregates.keys():
            assert key not in leaves
        leaves.update(aggregates)
        return leaves


### OFX RESPONSE
class OFXResponse(object):
    """ 
    Top-level object representing an OFX response converted into Python
    data types, with attributes for convenient access to statements (i.e.
    OFX *STMT aggregates), security descriptions (i.e. OFX SECLIST aggregate),
    and SONRS (server response to signon request).

    After conversion, each of these convenience attributes holds instances
    of various Aggregate subclasses.
    """
    sonrs = None
    statements = []
    securities = []

    def __init__(self, tree, strict=True):
        """ 
        Initialize with ElementTree instance containing parsed OFX.

        The strict argument determines whether to throw an error for certain
        OFX data validation violations.
        """
        # Keep a copy of the parse tree
        self.tree = tree

        # SONRS - server response to signon request
        sonrs = self.tree.find('SIGNONMSGSRSV1/SONRS')
        self.sonrs = sonrs.convert()

        # TRNRS - transaction response, which is the main section
        # containing account statements
        #
        # N.B. This iteration method doesn't preserve the original
        # ordering of the statements within the OFX response
        for stmtClass in (BankStatement, CreditCardStatement, InvestmentStatement):
            tagname = stmtClass._tagName
            for trnrs in self.tree.findall('*/%sTRNRS' % tagname):
                # *STMTTRNRS may have no *STMTRS (in case of error).
                # Don't blow up; skip silently.
                stmtrs = trnrs.find('%sRS' % tagname)
                if stmtrs is not None:
                    stmt = stmtClass(stmtrs)
                    # Staple the TRNRS wrapper data onto the STMT
                    stmt.copyTRNRS(trnrs)
                    self.statements.append(stmt)

        # SECLIST - list of description of securities referenced by
        # INVSTMT (investment account statement)
        seclist = self.tree.find('SECLISTMSGSRSV1/SECLIST')
        if seclist is None:
            return
        for sec in seclist:
            self.securities.append(sec.convert(strict=strict))

    def __repr__(self):
        s = "<%s fid='%s' org='%s' dtserver='%s' len(statements)=%d len(securities)=%d>"
        return s % (self.__class__.__name__, 
                    self.sonrs.fid, 
                    self.sonrs.org, 
                    str(self.sonrs.dtserver), 
                    len(self.statements), 
                    len(self.securities),
                   )

### STATEMENTS
class Statement(object):
    """ Base class for Python representation of OFX *STMT aggregate """
    # From TRNRS wrapper
    uid = None
    status = None
    cookie = None

    currency = None
    account = None

    transactions = []
    other_balances =[] 

    def __init__(self, stmtrs):
        """ Initialize with *STMTRS Element """
        self.currency = stmtrs.find('CURDEF').text
        self.account = stmtrs.find(self._acctTag).convert()
        self._init(stmtrs)

    def _init(self, stmtrs):
        # Define in subclass
        raise NotImplementedError
    
    def copyTRNRS(self, trnrs):
        """ Attach the data fields from the *TRNRS wrapper to the STMT """
        self.uid = elements.String(36).convert(trnrs.find('TRNUID').text)
        self.status = trnrs.find('STATUS').convert()
        cltcookie = trnrs.find('CLTCOOKIE')
        if cltcookie is not None:
            self.cookie = elements.String(36).convert(cltcookie.text)

    def __repr__(self):
        # Define in subclass
        raise NotImplementedError


class BankStatement(Statement):
    """ Python representation of OFX STMT (bank statement) aggregate """
    ledgerbal = None
    availbal = None

    _tagName = 'STMT'
    _acctTag = 'BANKACCTFROM'

    def _init(self, stmtrs):
        # BANKTRANLIST
        tranlist = stmtrs.find('BANKTRANLIST')
        if tranlist is not None:
            self.transactions = BANKTRANLIST(tranlist)

        # LEDGERBAL - mandatory
        self.ledgerbal = stmtrs.find('LEDGERBAL').convert()

        # AVAILBAL
        availbal = stmtrs.find('AVAILBAL')
        if availbal is not None:
            self.availbal = availbal.convert()

        # BALLIST
        ballist = stmtrs.find('BALLIST')
        if ballist:
            self.other_balances = [bal.convert() for bal in ballist]

        # Unsupported subaggregates
        for tag in ('MKTGINFO', ):
            child = stmtrs.find(tag)
            if child:
                stmtrs.remove

    def __repr__(self):
        s = "<%s account=%s currency=%s ledgerbal=%s availbal=%s len(other_balances)=%d len(transactions)=%d>"
        return s % (self.__class__.__name__, 
                    self.account,
                    self.currency,
                    self.ledgerbal, 
                    self.availbal, 
                    len(self.other_balances),
                    len(self.transactions), 
                   )


class CreditCardStatement(BankStatement):
    """ 
    Python representation of OFX CCSTMT (credit card statement) 
    aggregate 
    """
    _tagName = 'CCSTMT'
    _acctTag = 'CCACCTFROM'


class InvestmentStatement(Statement):
    """ 
    Python representation of OFX InvestmentStatement (investment account statement) 
    aggregate 
    """
    datetime = None

    positions = []
    balances = []

    _tagName = 'INVSTMT'
    _acctTag = 'INVACCTFROM'

    def _init(self, invstmtrs):
        dtasof = invstmtrs.find('DTASOF').text
        self.datetime = elements.DateTime.convert(dtasof)

        # INVTRANLIST
        tranlist = invstmtrs.find('INVTRANLIST')
        if tranlist is not None:
            self.transactions = INVTRANLIST(tranlist)

        # INVPOSLIST
        poslist = invstmtrs.find('INVPOSLIST')
        if poslist is not None:
            self.positions = [pos.convert() for pos in poslist]

        # INVBAL
        invbal = invstmtrs.find('INVBAL')
        if invbal is not None:
            # First strip off BALLIST & process it
            ballist = invbal.find('BALLIST')
            if ballist is not None:
                invbal.remove(ballist)
                self.other_balances = [bal.convert() for bal in ballist]
            # Now we can flatten the rest of INVBAL
            self.balances = invbal.convert()

        # Unsupported subaggregates
        for tag in ('INVOOLIST', 'INV401K', 'INV401KBAL', 'MKTGINFO'):
            child = invstmtrs.find(tag)
            if child is not None:
                invstmtrs.remove

    def __repr__(self):
        s = "<%s account=%s currency='%s' balances=%s len(other_balances)=%d len(positions)=%d len(transactions)=%d>"
        return s % (self.__class__.__name__, 
                    self.account,
                    self.currency,
                    self.balances, 
                    len(self.other_balances),
                    len(self.positions), 
                    len(self.transactions), 
                   )


### TRANSACTION LISTS
class TransactionList(list):
    """ 
    Base class for Python representation of OFX *TRANLIST (transaction list) 
    aggregate 
    """
    def __init__(self, tranlist):
        # Initialize with *TRANLIST Element
        dtstart, dtend = tranlist[0:2]
        tranlist = tranlist[2:]
        self.dtstart = elements.DateTime.convert(dtstart.text)
        self.dtend = elements.DateTime.convert(dtend.text)
        self.extend([tran.convert() for tran in tranlist])

    def __repr__(self):
        return "<%s dtstart='%s' dtend='%s' #transactions=%s>" % \
                (self.__class__.__name__, self.dtstart, self.dtend, len(self))


class BANKTRANLIST(TransactionList):
    """
    Python representation of OFX BANKTRANLIST (bank transaction list) 
    aggregate
    """
    pass


class INVTRANLIST(TransactionList):
    """
    Python representation of OFX INVTRANLIST (investment transaction list)
    aggregate 
    """
    pass


